#!/usr/bin/env python
import subprocess, json, os, ConfigParser
from optparse import OptionParser

usage = "usage: %prog [options] [server_number]\n\
  server_number: a numeric value corresponding to the server number\n\
  e.g.: '%prog 1' will ssh into the 1st server in the list."

parser = OptionParser(usage)
parser.add_option("-x", "--bust-cache", action="store_true",
    help="refetch servers list from AWS")
parser.add_option("-u", "--user", action="store",
          dest="user", default="",
    help="provide user (default: ubuntu)")
parser.add_option("-i", "--identity", action="store",
          dest="identity", default="",
    help="provide identity file")
parser.add_option("-p", "--profile", action="store",
          dest="profile", default="",
    help="provide AWS profile")
parser.add_option("-r", "--region", action="store",
          dest="region", default="",
    help="provide AWS region")
parser.add_option("--ip", action="store",
          dest="ip", default=0,
    help="connect using IP instead of DNS")
(options, args) = parser.parse_args()

cache_dir = os.environ.get('XDG_CACHE_HOME',
  os.path.join(os.path.expanduser('~'), '.cache'))
if not os.path.exists(cache_dir):
  os.makedirs(cache_dir)
if options.region:
  cache_file_list = os.path.join(cache_dir, 'ssh2_list_' + options.region)
  cache_file_num = os.path.join(cache_dir, 'ssh2_num_' + options.region)
else:
  cache_file_list = os.path.join(cache_dir, 'ssh2_list')
  cache_file_num = os.path.join(cache_dir, 'ssh2_num')
aws_credentials_dir = os.path.join(os.path.expanduser('~'), '.aws/credentials')

num = ''
if args:
  if not args[0].isdigit():
    print "'server_number' must be a numeric value"
    exit()
  num = int(args[0])


def extract_name(instance):
  if 'Tags' in instance:
    for tag in instance['Tags']:
      if tag['Key'] == 'Name' and tag['Value']:
        return tag['Value']
  return '.'

def extract_siblings(instance, all_instances):
    siblings = []
    i = 0
    for profile in all_instances:
        i += 1
        if profile != instance and instance['Profile'] == profile['Profile']:
            choice = '[%d]' % i
            name = extract_name(profile)
            siblings.append('"%-4s %-55s %-20s %-30s"' % (choice, profile.get('PrivateIpAddress', False) or profile.get('PrivateDnsName', False), profile['Profile'], name))
    return siblings


if options.bust_cache or not os.path.exists(cache_file_list) \
  or options.profile:
  reservations = {"Reservations": {}}
  
  if options.profile:
    profiles = [options.profile]
  elif os.path.exists(aws_credentials_dir):
    settings = ConfigParser.ConfigParser()
    settings.read(aws_credentials_dir);
    profiles = settings.sections()
  else: 
    profiles = ['']
  
  print "Fetching servers..."
  aws_cmd = 'aws ec2 describe-instances --filters Name=instance-state-name,Values=running '
  for profile in profiles:
    list_cmd = aws_cmd
    if (len(profile)):
      list_cmd += ' --profile ' + profile
    
    child = subprocess.Popen(list_cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    output = child.stdout.read()
    error = child.stderr.read()
    if error:
      print error
      print 'Unable to fetch any servers.'
      exit()
    reservations["Reservations"][profile] = json.loads(output)["Reservations"]
    
  with open(cache_file_list, 'w') as f:
    f.write(json.dumps(reservations))

output = open(cache_file_list).read()
parsed = json.loads(output)

all_instances = []
for profile in parsed['Reservations']:
  for instances in parsed['Reservations'][profile]:
    for instance in instances['Instances']:
      if len(instance['PublicDnsName']) or extract_name(instance) != '.':
        all_instances.append(dict(instance.items() + {'Profile': profile}.items()))
all_instances = sorted(all_instances, key=lambda x: (x['Profile'], extract_name));

if not num:
  print "\nServers list:\n"
  for i, instance in enumerate(all_instances, 1):
    choice = '[%d]' % i
    name = extract_name(instance)
    print '%-4s %-55s %-20s %-30s' % (choice, instance.get('PublicIpAddress', False) or instance.get('PrivateDnsName', False) or instance.get('PrivateIpAddress', False), instance['Profile'], name)

default_num = 1
if os.path.exists(cache_file_num):
  default_num = open(cache_file_num).read()
ok = not not num
while not ok or not num:
  try:
    num = raw_input("\nWhich server would you like to connect to [" +
            str(default_num) + "]? ")
    if not num:
      num = int(default_num)
      break
    ok = num.isdigit() and 1 <= int(num) <= i
    if ok:
      num = int(num)
      break
    print "ERR: please enter a value between 1 and " + str(i)
  except (EOFError, KeyboardInterrupt) as e:
    print "\nExiting..."
    exit()

with open(cache_file_num, 'w') as f:
  f.write(str(num))

instance = all_instances[num - 1]
dns = [
        instance.get('PublicDnsName', False) or instance.get('PublicIpAddress', False) or instance.get('PrivateDnsName', False) or instance.get('PrivateIpAddress', False), 
        instance.get('PublicIpAddress', False) or instance.get('PrivateIpAddress', False)
    ][options.ip]
key = instance['KeyName'] if 'KeyName' in instance else ''

print options.user
cache_file_user = os.path.join(cache_dir, 'ssh2_user_' + dns)
default_user = 'ubuntu'
if os.path.exists(cache_file_user):
  default_user = open(cache_file_user).read()
ok = not not default_user
while not ok or not options.user:
  try:
    options.user = raw_input("Which username would you like to connect with [" +
            str(default_user) + "]? ")
    if not options.user:
      options.user = default_user
      break
    ok = not not options.user
    if ok:
      break
  except (EOFError, KeyboardInterrupt) as e:
    print "\nExiting..."
    exit()
with open(cache_file_user, 'w') as f:
  f.write(str(options.user))

identity = ''
if options.identity and os.path.exists(options.identity):
  identity = "-i %s " % options.identity
elif (len(key)):
  identity = "-i ~/.ssh/%s.pem " % key 

# Add all private keys to ssh-client
directory = os.path.join(os.path.expanduser('~'), '.ssh')
for filename in os.listdir(directory):
  contents = open(os.path.join(directory, filename)).read()
  if "-----BEGIN RSA PRIVATE KEY-----" in contents:
    os.system('ssh-add %s > /dev/null 2>&1' % os.path.join(directory, filename))

# Generate ssh helper files

ssh_hop = """#!/bin/bash
offset=1

declare -a arr=(
    """ + "\n".join(extract_siblings(instance, all_instances)) + """
)
for i in "${arr[@]}"
do
   echo "$i"
done

selection="none"
while ! [[ $selection =~ ^[0-9]+$ ]] || (($selection >= ${#arr[@]}))
do
    printf "\nWhich server would you like to connect to? "
    read choice
    for i in "${!arr[@]}"
    do
        val=$(echo "${arr[$i]}" | grep "^\[$choice\]" > /dev/null 2>&1)
        if [[ $? == 0 ]]; then
            selection=$i
            break
        fi
    done
done

host="$(echo ${arr[$selection]} | awk '{print $2}')"
/bin/bash -c "ssh """ + options.user + """@$host"
"""

scp_ssh2 = os.path.join(cache_dir, 'ssh2')
with open(scp_ssh2, 'w') as f:
    f.write(ssh_hop)

ssh_connect = 'ssh -A -K %s%s@%s' % (identity, options.user, dns)
print "\nConnecting to", extract_name(instance), 'using "' + ssh_connect + '"'

# Attempt to connect
try:
  code = 0
  output = subprocess.check_output(ssh_connect + " exit", shell=True)
except (subprocess.CalledProcessError) as e:
  code = e.returncode

# If connected, add ssh2 helper files
if code == 0:
    # Add $HOME to $PATH
    os.system(ssh_connect + " 'grep -q -F \"export PATH=\\\"$PATH:$HOME\\\"\" \"$HOME/.profile\" || echo \"export PATH=\\\"$PATH:$HOME\\\"\"  >>  \"$HOME/.profile\"'")
    # Add ssh2 sibling file to hop to linked machines
    os.system('scp -o \"ForwardAgent=yes\"  %s %s@%s:~/ssh2 > /dev/null 2>&1' % (scp_ssh2, options.user, dns))
    # update file permissions
    os.system(ssh_connect + " 'chmod 744 ~/ssh2' > /dev/null 2>&1")

os.system('ssh -A -K %s%s@%s' % (identity, options.user, dns))